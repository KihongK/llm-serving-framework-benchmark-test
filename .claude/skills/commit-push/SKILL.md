---
name: commit-push
description: 변경 사항 분석, 브랜치 전략 제안 및 의존성을 고려한 순차적 커밋 & Conventional Commit 규격에 따른 자동 커밋/푸시
---

변경 사항을 처리할 때 다음 단계를 엄격히 준수하세요:

### 1. 현황 분석 및 브랜치 전략 제안
* **브랜치 확인**: 현재 브랜치 이름과 상태를 확인합니다.
* **전략 판단**: 변경 사항의 규모와 성격을 분석합니다. 
    * 기존 브랜치(예: `main`, `develop`)에서 직접 커밋하는 것이 위험하거나, 작업 단위가 독립적이라면 **새 브랜치 생성**을 강력히 권장합니다.
    * 사용자에게 "현재 브랜치에서 진행할까요, 아니면 추천드리는 새 브랜치(`feature/작업명` 등)로 이동할까요?"라고 먼저 묻습니다.

### 2. 논리적 커밋 구분 (Atomic Commits)
* **변경 사항 분류**: 한꺼번에 모든 파일을 커밋하지 않습니다. 기능 수정, 리팩토링, 설정 변경 등 성격이 다른 파일들을 논리적 단위로 그룹화합니다.
* **메시지 작성**: Conventional Commits 규칙을 참고하여 명확한 커밋 메시지를 작성합니다.
* **의존성 확인**: 각 커밋 단위에는 수정되는 기능에 의존성 내용을 점검하고 반영합니다.

### 3. 실행 및 푸시
* **체크아웃**: 브랜치 변경이 결정되면 해당 브랜치를 생성하고 이동합니다.
* **순차 커밋**: 구분된 그룹별로 `git add` 및 `git commit`을 수행합니다.
* **푸시**: 모든 커밋이 완료되면 `git push`를 실행합니다. (새 브랜치인 경우 `-u` 옵션 포함)

### 4. 사후 보고
* 생성된 브랜치 이름, 커밋 메시지 목록, 그리고 푸시된 결과를 요약하여 대화체로 보고합니다.

> **주의 사항**: 
> * `main` 또는 `master` 브랜치에 직접 푸시하기 전에는 반드시 경고를 표시하세요.
> * 충돌(Conflict) 가능성이 보이면 미리 사용자에게 알립니다.

### Commit Convention 규칙
커밋 메시지를 생성할 때는 다음 형식을 반드시 준수합니다:

1. **타입 강제**: 작업 내용에 따라 아래 중 하나를 선택합니다.
   - `feat`: 신규 기능
   - `fix`: 버그 수정
   - `docs`: 문서 변경
   - `style`: 코드 포맷팅 (로직 변경 없음)
   - `refactor`: 코드 리팩토링
   - `test`: 테스트 코드 추가/수정
   - `chore`: 기타 설정 변경

2. **메시지 언어**: 영어
3. **본문(Body) 추가 조건**: 
   - 변경 사항이 복잡하거나 파일이 3개 이상인 경우, 왜(Why) 이 작업을 했는지 본문에 설명을 추가합니다.
   - 파괴적 변경(Breaking Change)이 있다면 `BREAKING CHANGE:` 키워드를 포함합니다.

